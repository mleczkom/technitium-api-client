/*
Technitium API

Go SDK for interacting with Technitium APIs (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 12.2.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package technitium

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DnsZoneAPIService DnsZoneAPI service
type DnsZoneAPIService service

type ApiCreateDnsZoneRequest struct {
	ctx context.Context
	ApiService *DnsZoneAPIService
	zone *string
	type_ *string
	useSoaSerialDateScheme *bool
	primaryNameServerAddresses *[]string
	zoneTransferProtocol *string
	protocol *string
	forwarder *string
	dnssecValidation *bool
	proxyType *string
	proxyAddress *string
	proxyPort *string
	proxyUsername *string
	proxyPassword *string
}

// The domain name for creating the new zone. The value can be valid domain name, an IP address,  or an network address in CIDR format. When value is IP address or network address, a reverse zone is created. 
func (r ApiCreateDnsZoneRequest) Zone(zone string) ApiCreateDnsZoneRequest {
	r.zone = &zone
	return r
}

// The type of zone to be created. Valid values are [Primary, Secondary, Stub, Forwarder]
func (r ApiCreateDnsZoneRequest) Type_(type_ string) ApiCreateDnsZoneRequest {
	r.type_ = &type_
	return r
}

// Set value to true to enable using date scheme for SOA serial. This optional parameter is used  only with Primary zone. Default value is false 
func (r ApiCreateDnsZoneRequest) UseSoaSerialDateScheme(useSoaSerialDateScheme bool) ApiCreateDnsZoneRequest {
	r.useSoaSerialDateScheme = &useSoaSerialDateScheme
	return r
}

// List of comma separated IP addresses of the primary name server. This optional parameter is used only with Secondary and Stub zones. If this parameter is not used, the DNS server will try to recursively resolve the primary name server addresses automatically 
func (r ApiCreateDnsZoneRequest) PrimaryNameServerAddresses(primaryNameServerAddresses []string) ApiCreateDnsZoneRequest {
	r.primaryNameServerAddresses = &primaryNameServerAddresses
	return r
}

// The zone transfer protocol to be used by secondary zones. Valid values are [Tcp, Tls, Quic] 
func (r ApiCreateDnsZoneRequest) ZoneTransferProtocol(zoneTransferProtocol string) ApiCreateDnsZoneRequest {
	r.zoneTransferProtocol = &zoneTransferProtocol
	return r
}

// The DNS transport protocol to be used by the conditional forwarder zone. This optional parameter is used with Conditional Forwarder zones. Valid values are [Udp, Tcp, Tls, Https, Quic]. Default Udp protocol is used when this parameter is missing 
func (r ApiCreateDnsZoneRequest) Protocol(protocol string) ApiCreateDnsZoneRequest {
	r.protocol = &protocol
	return r
}

// The address of the DNS server to be used as a forwarder. This optional parameter is required to be used with Conditional Forwarder zones. A special value this-server can be used as a forwarder which when used will forward all the requests internally to this DNS server such that you can override the zone with records and rest of the zone gets resolved via This Server  
func (r ApiCreateDnsZoneRequest) Forwarder(forwarder string) ApiCreateDnsZoneRequest {
	r.forwarder = &forwarder
	return r
}

// Set this boolean value to indicate if DNSSEC validation must be done. This optional parameter is required  to be used with Conditional Forwarder zones 
func (r ApiCreateDnsZoneRequest) DnssecValidation(dnssecValidation bool) ApiCreateDnsZoneRequest {
	r.dnssecValidation = &dnssecValidation
	return r
}

// The type of proxy that must be used for conditional forwarding. This optional parameter is required to be used with Conditional Forwarder zones. Valid values are [NoProxy, DefaultProxy, Http, Socks5].  Default value DefaultProxy is used when this parameter is missing 
func (r ApiCreateDnsZoneRequest) ProxyType(proxyType string) ApiCreateDnsZoneRequest {
	r.proxyType = &proxyType
	return r
}

// The proxy server address to use when proxyType is configured. This optional parameter is required to be used with Conditional Forwarder zones 
func (r ApiCreateDnsZoneRequest) ProxyAddress(proxyAddress string) ApiCreateDnsZoneRequest {
	r.proxyAddress = &proxyAddress
	return r
}

// The proxy server port to use when proxyType is configured. This optional parameter is required to be used with Conditional Forwarder zones 
func (r ApiCreateDnsZoneRequest) ProxyPort(proxyPort string) ApiCreateDnsZoneRequest {
	r.proxyPort = &proxyPort
	return r
}

// The proxy server username to use when proxyType is configured. This optional parameter is required to be used with Conditional Forwarder zones 
func (r ApiCreateDnsZoneRequest) ProxyUsername(proxyUsername string) ApiCreateDnsZoneRequest {
	r.proxyUsername = &proxyUsername
	return r
}

// The proxy server password to use when proxyType is configured. This optional parameter is required to be used with Conditional Forwarder zones 
func (r ApiCreateDnsZoneRequest) ProxyPassword(proxyPassword string) ApiCreateDnsZoneRequest {
	r.proxyPassword = &proxyPassword
	return r
}

func (r ApiCreateDnsZoneRequest) Execute() (*CreateZoneResponse, *http.Response, error) {
	return r.ApiService.CreateDnsZoneExecute(r)
}

/*
CreateDnsZone Creates a new authoritative zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDnsZoneRequest
*/
func (a *DnsZoneAPIService) CreateDnsZone(ctx context.Context) ApiCreateDnsZoneRequest {
	return ApiCreateDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateZoneResponse
func (a *DnsZoneAPIService) CreateDnsZoneExecute(r ApiCreateDnsZoneRequest) (*CreateZoneResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateZoneResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsZoneAPIService.CreateDnsZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zone == nil {
		return localVarReturnValue, nil, reportError("zone is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "zone", r.zone, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.useSoaSerialDateScheme != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useSoaSerialDateScheme", r.useSoaSerialDateScheme, "form", "")
	}
	if r.primaryNameServerAddresses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primaryNameServerAddresses", r.primaryNameServerAddresses, "form", "csv")
	}
	if r.zoneTransferProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneTransferProtocol", r.zoneTransferProtocol, "form", "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "form", "")
	}
	if r.forwarder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forwarder", r.forwarder, "form", "")
	}
	if r.dnssecValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dnssecValidation", r.dnssecValidation, "form", "")
	}
	if r.proxyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxyType", r.proxyType, "form", "")
	}
	if r.proxyAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxyAddress", r.proxyAddress, "form", "")
	}
	if r.proxyPort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxyPort", r.proxyPort, "form", "")
	}
	if r.proxyUsername != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxyUsername", r.proxyUsername, "form", "")
	}
	if r.proxyPassword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "proxyPassword", r.proxyPassword, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDnsZoneRequest struct {
	ctx context.Context
	ApiService *DnsZoneAPIService
	zone *string
}

// Dns zone name
func (r ApiDeleteDnsZoneRequest) Zone(zone string) ApiDeleteDnsZoneRequest {
	r.zone = &zone
	return r
}

func (r ApiDeleteDnsZoneRequest) Execute() (*CommonResponse, *http.Response, error) {
	return r.ApiService.DeleteDnsZoneExecute(r)
}

/*
DeleteDnsZone Deletes an authoritative zone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteDnsZoneRequest
*/
func (a *DnsZoneAPIService) DeleteDnsZone(ctx context.Context) ApiDeleteDnsZoneRequest {
	return ApiDeleteDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommonResponse
func (a *DnsZoneAPIService) DeleteDnsZoneExecute(r ApiDeleteDnsZoneRequest) (*CommonResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommonResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsZoneAPIService.DeleteDnsZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zone == nil {
		return localVarReturnValue, nil, reportError("zone is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "zone", r.zone, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDnsZoneOptionsRequest struct {
	ctx context.Context
	ApiService *DnsZoneAPIService
	zone *string
	includeAvailableTsigKeyNames *bool
}

// The domain name of the zone to get options
func (r ApiGetDnsZoneOptionsRequest) Zone(zone string) ApiGetDnsZoneOptionsRequest {
	r.zone = &zone
	return r
}

// Set to true to include list of available TSIG key names on the DNS server
func (r ApiGetDnsZoneOptionsRequest) IncludeAvailableTsigKeyNames(includeAvailableTsigKeyNames bool) ApiGetDnsZoneOptionsRequest {
	r.includeAvailableTsigKeyNames = &includeAvailableTsigKeyNames
	return r
}

func (r ApiGetDnsZoneOptionsRequest) Execute() (*GetZoneOptionsResponse, *http.Response, error) {
	return r.ApiService.GetDnsZoneOptionsExecute(r)
}

/*
GetDnsZoneOptions Gets the zone specific options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDnsZoneOptionsRequest
*/
func (a *DnsZoneAPIService) GetDnsZoneOptions(ctx context.Context) ApiGetDnsZoneOptionsRequest {
	return ApiGetDnsZoneOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetZoneOptionsResponse
func (a *DnsZoneAPIService) GetDnsZoneOptionsExecute(r ApiGetDnsZoneOptionsRequest) (*GetZoneOptionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetZoneOptionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsZoneAPIService.GetDnsZoneOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/options/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zone == nil {
		return localVarReturnValue, nil, reportError("zone is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "zone", r.zone, "form", "")
	if r.includeAvailableTsigKeyNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAvailableTsigKeyNames", r.includeAvailableTsigKeyNames, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDnsZonesRequest struct {
	ctx context.Context
	ApiService *DnsZoneAPIService
	pageNumber *int32
	zonesPerPage *int32
}

// When this parameter is specified, the API will return paginated results based on the page number and  zones per pages options. When not specified, the API will return a list of all zones. 
func (r ApiListDnsZonesRequest) PageNumber(pageNumber int32) ApiListDnsZonesRequest {
	r.pageNumber = &pageNumber
	return r
}

// The number of zones per page to be returned. This option is only used when pageNumber options is specified. The default value is 10 when not specified. 
func (r ApiListDnsZonesRequest) ZonesPerPage(zonesPerPage int32) ApiListDnsZonesRequest {
	r.zonesPerPage = &zonesPerPage
	return r
}

func (r ApiListDnsZonesRequest) Execute() (*ListZonesResponse, *http.Response, error) {
	return r.ApiService.ListDnsZonesExecute(r)
}

/*
ListDnsZones List all authoritative zones hosted on this DNS server. The list contains only the zones that the user has View permissions for. These API calls requires permission for both the Zones section as well as the individual permission for each zone. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDnsZonesRequest
*/
func (a *DnsZoneAPIService) ListDnsZones(ctx context.Context) ApiListDnsZonesRequest {
	return ApiListDnsZonesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListZonesResponse
func (a *DnsZoneAPIService) ListDnsZonesExecute(r ApiListDnsZonesRequest) (*ListZonesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListZonesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsZoneAPIService.ListDnsZones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	}
	if r.zonesPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zonesPerPage", r.zonesPerPage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDnsZoneOptionsRequest struct {
	ctx context.Context
	ApiService *DnsZoneAPIService
	zone *string
	disabled *bool
	zoneTransfer *string
	zoneTransferNameServers *[]string
	zoneTransferTsigKeyNames *[]string
	notify *string
	notifyNameServers *[]string
	update *string
	updateIpAddresses *[]string
}

// The domain name of the zone to set options
func (r ApiSetDnsZoneOptionsRequest) Zone(zone string) ApiSetDnsZoneOptionsRequest {
	r.zone = &zone
	return r
}

// Sets if the zone is enabled or disabled
func (r ApiSetDnsZoneOptionsRequest) Disabled(disabled bool) ApiSetDnsZoneOptionsRequest {
	r.disabled = &disabled
	return r
}

// Sets if the zone allows zone transfer. Valid options are [Deny, Allow, AllowOnlyZoneNameServers, AllowOnlySpecifiedNameServers,  AllowBothZoneAndSpecifiedNameServers]. This option is valid only for Primary and Secondary zones. 
func (r ApiSetDnsZoneOptionsRequest) ZoneTransfer(zoneTransfer string) ApiSetDnsZoneOptionsRequest {
	r.zoneTransfer = &zoneTransfer
	return r
}

// A list of comma separated IP or network addresses which should be allowed to perform zone transfer. This list is enabled only when zoneTransfer option is set to AllowOnlySpecifiedNameServers or  AllowBothZoneAndSpecifiedNameServers. This option is valid only for Primary and Secondary zones 
func (r ApiSetDnsZoneOptionsRequest) ZoneTransferNameServers(zoneTransferNameServers []string) ApiSetDnsZoneOptionsRequest {
	r.zoneTransferNameServers = &zoneTransferNameServers
	return r
}

// A list of comma separated TSIG keys names that are authorized to perform a zone transfer. Set this option to false to clear all key names. This option is valid only for Primary and Secondary zones 
func (r ApiSetDnsZoneOptionsRequest) ZoneTransferTsigKeyNames(zoneTransferTsigKeyNames []string) ApiSetDnsZoneOptionsRequest {
	r.zoneTransferTsigKeyNames = &zoneTransferTsigKeyNames
	return r
}

// Sets if the DNS server should notify other DNS servers for zone updates. Valid options are [None, ZoneNameServers,  SpecifiedNameServers, BothZoneAndSpecifiedNameServers]. This option is valid only for Primary and Secondary zones. 
func (r ApiSetDnsZoneOptionsRequest) Notify(notify string) ApiSetDnsZoneOptionsRequest {
	r.notify = &notify
	return r
}

// A list of comma separated IP addresses which should be notified by the DNS server for zone updates. This list is used only when notify option is set to SpecifiedNameServers or BothZoneAndSpecifiedNameServers. This option is valid only for Primary and Secondary zones. 
func (r ApiSetDnsZoneOptionsRequest) NotifyNameServers(notifyNameServers []string) ApiSetDnsZoneOptionsRequest {
	r.notifyNameServers = &notifyNameServers
	return r
}

// Sets if the DNS server should allow dynamic updates (RFC 2136). This option is valid only  for Primary, Secondary and Forwarder zones. Valid options for Primary zones are [Deny, Allow,  AllowOnlyZoneNameServers, AllowOnlySpecifiedIpAddresses, AllowBothZoneNameServersAndSpecifiedIpAddresses]. Valid options for Secondary and Forwarder zones are [Deny, Allow, AllowOnlySpecifiedIpAddresses]. 
func (r ApiSetDnsZoneOptionsRequest) Update(update string) ApiSetDnsZoneOptionsRequest {
	r.update = &update
	return r
}

// A list of comma separated IP or network addresses which should be allowed to perform dynamic updates. This list is enabled only when update option is set to AllowOnlySpecifiedIpAddresses or AllowBothZoneNameServersAndSpecifiedIpAddresses. This option is valid only for Primary,  Secondary and Forwarder zones 
func (r ApiSetDnsZoneOptionsRequest) UpdateIpAddresses(updateIpAddresses []string) ApiSetDnsZoneOptionsRequest {
	r.updateIpAddresses = &updateIpAddresses
	return r
}

func (r ApiSetDnsZoneOptionsRequest) Execute() (*CommonResponse, *http.Response, error) {
	return r.ApiService.SetDnsZoneOptionsExecute(r)
}

/*
SetDnsZoneOptions Sets the zone specific options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetDnsZoneOptionsRequest
*/
func (a *DnsZoneAPIService) SetDnsZoneOptions(ctx context.Context) ApiSetDnsZoneOptionsRequest {
	return ApiSetDnsZoneOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CommonResponse
func (a *DnsZoneAPIService) SetDnsZoneOptionsExecute(r ApiSetDnsZoneOptionsRequest) (*CommonResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommonResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DnsZoneAPIService.SetDnsZoneOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/zones/options/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.zone == nil {
		return localVarReturnValue, nil, reportError("zone is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "zone", r.zone, "form", "")
	if r.disabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disabled", r.disabled, "form", "")
	}
	if r.zoneTransfer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneTransfer", r.zoneTransfer, "form", "")
	}
	if r.zoneTransferNameServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneTransferNameServers", r.zoneTransferNameServers, "form", "csv")
	}
	if r.zoneTransferTsigKeyNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneTransferTsigKeyNames", r.zoneTransferTsigKeyNames, "form", "csv")
	}
	if r.notify != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notify", r.notify, "form", "")
	}
	if r.notifyNameServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "notifyNameServers", r.notifyNameServers, "form", "csv")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "form", "")
	}
	if r.updateIpAddresses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateIpAddresses", r.updateIpAddresses, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
